# NAATI Multi-Environment CI/CD Pipeline
# This pipeline supports deployment to multiple environments with approval gates

trigger:
  branches:
    include:
    - main
    - develop
    - release/*

pr:
  branches:
    include:
    - main
    - develop

parameters:
- name: deployToEnvironments
  displayName: 'Deploy to Environments'
  type: object
  default:
  - environment: 'DEV'
    aksContext: 'akscluster-dev'
    requireApproval: false
  - environment: 'UAT'
    aksContext: 'akscluster-uat'
    requireApproval: true
  - environment: 'PROD'
    aksContext: 'aksclustertest'
    requireApproval: true

variables:
  # Build Configuration
  buildConfiguration: 'Release'
  solution: 'Naati/Naati.sln'
  
  # Container Registry
  containerRegistry: 'acrtest0002.azurecr.io'
  repositoryName: 'acrtest0002'
  naatiBaseImageName: 'naatibase'
  ncmsImageName: 'ncmsui'
  myNaatiImageName: 'mynaatiui'
  
  # Versioning
  version: '2.0.0'
  branchPrefix: 'ci'
  
  # Build paths
  buildSourcesDirectory: '$(Agent.TempDirectory)/Build/s'
  buildStagingDirectory: '$(Agent.TempDirectory)/Build/a'
  buildPackagesDirectory: '$(Agent.TempDirectory)/BuildHelmPackages'
  
  # Testing
  runTests: true

# Use your self-hosted agent pool
pool:
  name: 'Default'  # Replace with your actual agent pool name

stages:
# Stage 1: Build and Test (Same as main pipeline)
- stage: BuildAndTest
  displayName: 'Build and Test Applications'
  jobs:
  - job: Build
    displayName: 'Build NAATI Applications'
    timeoutInMinutes: 90
    
    steps:
    # Checkout with clean option
    - checkout: self
      clean: true
      fetchDepth: 1
    
    # Setup build environment
    - task: PowerShell@2
      displayName: 'Setup Build Environment'
      inputs:
        targetType: 'inline'
        script: |
          Write-Host "Setting up build environment..."
          
          # Create required directories
          $buildDirs = @(
            "$(buildSourcesDirectory)",
            "$(buildStagingDirectory)", 
            "$(buildPackagesDirectory)"
          )
          
          foreach ($dir in $buildDirs) {
            if (Test-Path $dir) {
              Write-Host "Cleaning existing directory: $dir"
              Remove-Item -Path "$dir\*" -Force -Recurse -ErrorAction SilentlyContinue
            } else {
              New-Item -ItemType Directory -Path $dir -Force
              Write-Host "Created directory: $dir"
            }
          }
          
          # Set environment variables
          Write-Host "##vso[task.setvariable variable=BUILD_SOURCESDIRECTORY]$(buildSourcesDirectory)"
          Write-Host "##vso[task.setvariable variable=BUILD_STAGINGDIRECTORY]$(buildStagingDirectory)"
          
          # Generate build number with consecutive counter
          $consecutiveFile = "$(buildPackagesDirectory)/buildConsecutive"
          if (Test-Path $consecutiveFile) {
            $consecutive = [int](Get-Content $consecutiveFile) + 1
          } else {
            $consecutive = 1
          }
          $consecutive | Out-File $consecutiveFile
          
          $dateNumber = Get-Date -Format "yyyyMMdd"
          $buildNumber = "NAATI ALL - CI_$dateNumber.$consecutive"
          Write-Host "##vso[task.setvariable variable=ContainerTag]$buildNumber"
          Write-Host "##vso[task.setvariable variable=HelmPackage]naati-$buildNumber"
          Write-Host "Build Number: $buildNumber"
    
    # Copy source files to build directory
    - task: PowerShell@2
      displayName: 'Copy Source Files'
      inputs:
        targetType: 'inline'
        script: |
          Write-Host "Copying source files to build directory..."
          $sourceDir = "$(Build.SourcesDirectory)/Naati"
          $targetDir = "$(buildSourcesDirectory)/Naati"
          
          if (!(Test-Path $targetDir)) {
            New-Item -ItemType Directory -Path $targetDir -Force
          }
          
          robocopy "$sourceDir" "$targetDir" /E /R:3 /W:5 /MT:8
          if ($LASTEXITCODE -gt 7) {
            Write-Error "Failed to copy source files"
            exit 1
          }
          
          Write-Host "Source files copied successfully"
    
    # Run pre-build script
    - task: PowerShell@2
      displayName: 'Run Pre-Build Script'
      inputs:
        targetType: 'filePath'
        filePath: '$(buildSourcesDirectory)/Naati/Deployment Scripts/PreBuildScript.ps1'
        arguments: '$(version).X'
        workingDirectory: '$(buildSourcesDirectory)'
    
    # Build NCMS.UI using MSBuild
    - task: MSBuild@1
      displayName: 'Build and Publish NCMS.UI'
      inputs:
        solution: '$(buildSourcesDirectory)/Naati/Ncms.Ui/Ncms.Ui.csproj'
        msbuildArguments: '/nr:false /nologo /p:DeployDefaultTarget=WebPublish /p:WebPublishMethod=FileSystem /p:DeleteExistingFiles=True /p:publishUrl=$(buildStagingDirectory)/Ncms.Ui/_PublishedWebsites/Ncms.Ui /t:WebPublish /p:Platform=AnyCPU /p:Configuration=$(buildConfiguration) /m'
        platform: 'Any CPU'
        configuration: '$(buildConfiguration)'
    
    # Build MyNaati.UI using MSBuild
    - task: MSBuild@1
      displayName: 'Build and Publish MyNaati.UI'
      inputs:
        solution: '$(buildSourcesDirectory)/Naati/MyNaati.Ui/MyNaati.Ui.csproj'
        msbuildArguments: '/nologo /nr:false /p:DeployDefaultTarget=WebPublish /p:WebPublishMethod=FileSystem /p:DeleteExistingFiles=True /p:publishUrl=$(buildStagingDirectory)/MyNaati.Ui/_PublishedWebsites/MyNaati.Ui /t:WebPublish /p:Platform=AnyCPU /p:Configuration=$(buildConfiguration) /m'
        platform: 'Any CPU'
        configuration: '$(buildConfiguration)'
    
    # Build and run tests
    - task: PowerShell@2
      displayName: 'Build and Run Tests'
      condition: eq(variables.runTests, true)
      inputs:
        targetType: 'inline'
        script: |
          Write-Host "Building test projects..."
          
          # Find MSBuild
          $msBuildPaths = @(
            "C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\MSBuild\Current\Bin\Msbuild.exe",
            "C:\Program Files\Microsoft Visual Studio\2022\Enterprise\MSBuild\Current\Bin\Msbuild.exe",
            "C:\Program Files\Microsoft Visual Studio\2022\Professional\MSBuild\Current\Bin\Msbuild.exe"
          )
          
          $msBuild = $msBuildPaths | Where-Object { Test-Path $_ } | Select-Object -First 1
          if (!$msBuild) {
            Write-Error "MSBuild not found"
            exit 1
          }
          
          # Build test projects
          & $msBuild "$(buildSourcesDirectory)/Naati/MyNaati.Test/MyNaati.Test.csproj" /nologo /nr:false /p:OutDir=$(buildStagingDirectory)/MyNaati.Test /p:Platform=AnyCPU /p:Configuration=$(buildConfiguration) /m
          & $msBuild "$(buildSourcesDirectory)/Naati/Ncms.Test/Ncms.Test.csproj" /nologo /nr:false /p:OutDir=$(buildStagingDirectory)/Ncms.Test /p:Platform=AnyCPU /p:Configuration=$(buildConfiguration) /m
          
          # Find test console
          $testConsolePaths = @(
            "C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\Common7\IDE\Extensions\TestPlatform\vstest.console.exe",
            "C:\Program Files\Microsoft Visual Studio\2022\Enterprise\Common7\IDE\Extensions\TestPlatform\vstest.console.exe",
            "C:\Program Files\Microsoft Visual Studio\2022\Professional\Common7\IDE\Extensions\TestPlatform\vstest.console.exe"
          )
          
          $testConsole = $testConsolePaths | Where-Object { Test-Path $_ } | Select-Object -First 1
          if (!$testConsole) {
            Write-Error "VSTest console not found"
            exit 1
          }
          
          # Run tests
          & $testConsole "$(buildStagingDirectory)/MyNaati.Test/MyNaati.Test.dll" "$(buildStagingDirectory)/Ncms.Test/Ncms.Test.dll" /EnableCodeCoverage /InIsolation /logger:trx
    
    # Publish build artifacts
    - task: PublishBuildArtifacts@1
      displayName: 'Publish Build Artifacts'
      inputs:
        pathToPublish: '$(buildStagingDirectory)'
        artifactName: 'build-output'
    
    # Publish test results
    - task: PublishTestResults@2
      displayName: 'Publish Test Results'
      condition: eq(variables.runTests, true)
      inputs:
        testResultsFormat: 'VSTest'
        testResultsFiles: '**/*.trx'
        searchFolder: '$(Agent.TempDirectory)'

# Stage 2: Build and Push Docker Images
- stage: DockerBuildPush
  displayName: 'Build and Push Docker Images'
  dependsOn: BuildAndTest
  jobs:
  - job: BuildDockerImages
    displayName: 'Build and Push Docker Images'
    timeoutInMinutes: 60
    
    steps:
    # Download build artifacts
    - task: DownloadBuildArtifacts@0
      displayName: 'Download Build Artifacts'
      inputs:
        buildType: 'current'
        downloadType: 'single'
        artifactName: 'build-output'
        downloadPath: '$(Agent.TempDirectory)'
    
    # Setup Docker environment
    - task: PowerShell@2
      displayName: 'Setup Docker Environment'
      inputs:
        targetType: 'inline'
        script: |
          # Recreate build environment variables
          Write-Host "##vso[task.setvariable variable=BUILD_SOURCESDIRECTORY]$(buildSourcesDirectory)"
          Write-Host "##vso[task.setvariable variable=BUILD_STAGINGDIRECTORY]$(buildStagingDirectory)"
          
          # Copy build output back to expected location
          $buildOutput = "$(Agent.TempDirectory)/build-output"
          if (!(Test-Path "$(buildStagingDirectory)")) {
            New-Item -ItemType Directory -Path "$(buildStagingDirectory)" -Force
          }
          robocopy "$buildOutput" "$(buildStagingDirectory)" /E /R:3 /W:5
    
    # Copy Docker files
    - task: PowerShell@2
      displayName: 'Copy Docker Files'
      inputs:
        targetType: 'filePath'
        filePath: '$(Build.SourcesDirectory)/Naati/Deployment Scripts/CopyDockerFiles.ps1'
        arguments: '$(buildStagingDirectory) "$(containerRegistry)/$(naatiBaseImageName)" $(ContainerTag)'
        workingDirectory: '$(buildSourcesDirectory)'
    
    # Login to Azure Container Registry
    - task: AzureCLI@2
      displayName: 'Login to ACR'
      inputs:
        azureSubscription: 'YourAzureServiceConnection'  # Replace with your service connection
        scriptType: 'ps'
        scriptLocation: 'inlineScript'
        inlineScript: |
          az acr login --name $(repositoryName)
    
    # Build and push all images
    - task: PowerShell@2
      displayName: 'Build and Push All Images'
      inputs:
        targetType: 'inline'
        script: |
          $dockerExe = "docker"
          
          # Build and push NaatiBase image
          Write-Host "Building NaatiBase image..."
          & $dockerExe build -f "$(Build.SourcesDirectory)/Naati/Deployment Scripts/Docker/NaatiBase/DockerFile" -t "$(containerRegistry)/$(naatiBaseImageName):$(ContainerTag)" "$(Build.SourcesDirectory)/Naati/Deployment Scripts/Docker/NaatiBase"
          Write-Host "Pushing NaatiBase image..."
          & $dockerExe push "$(containerRegistry)/$(naatiBaseImageName):$(ContainerTag)"
          
          # Build and push NCMS image
          Write-Host "Building NCMS image..."
          & $dockerExe build -f "$(buildStagingDirectory)/Ncms.Ui/_PublishedWebsites/Ncms.Ui/DockerFile" -t "$(containerRegistry)/$(ncmsImageName):$(ContainerTag)" "$(buildStagingDirectory)/Ncms.Ui/_PublishedWebsites/Ncms.Ui"
          Write-Host "Pushing NCMS image..."
          & $dockerExe push "$(containerRegistry)/$(ncmsImageName):$(ContainerTag)"
          
          # Build and push MyNaati image
          Write-Host "Building MyNaati image..."
          & $dockerExe build -f "$(buildStagingDirectory)/MyNaati.Ui/_PublishedWebsites/MyNaati.Ui/DockerFile" -t "$(containerRegistry)/$(myNaatiImageName):$(ContainerTag)" "$(buildStagingDirectory)/MyNaati.Ui/_PublishedWebsites/MyNaati.Ui"
          Write-Host "Pushing MyNaati image..."
          & $dockerExe push "$(containerRegistry)/$(myNaatiImageName):$(ContainerTag)"

# Stage 3: Helm Package Management
- stage: HelmPackaging
  displayName: 'Helm Package Management'
  dependsOn: DockerBuildPush
  jobs:
  - job: HelmOperations
    displayName: 'Push and Backup Helm Packages'
    
    steps:
    # Push Helm packages
    - task: PowerShell@2
      displayName: 'Push Helm Packages'
      inputs:
        targetType: 'filePath'
        filePath: '$(Build.SourcesDirectory)/Naati/Deployment Scripts/PushHelmPackages.ps1'
        arguments: '-naatiRepositoryName $(repositoryName) -helmFolder "$(Build.SourcesDirectory)/Naati/Deployment Scripts/Helm"'
        workingDirectory: '$(buildSourcesDirectory)'
    
    # Backup Helm packages
    - task: PowerShell@2
      displayName: 'Backup Helm Packages'
      inputs:
        targetType: 'filePath'
        filePath: '$(Build.SourcesDirectory)/Naati/Deployment Scripts/CopyHelmToDropFolder.ps1'
        arguments: '-dropFolder $(buildPackagesDirectory) -helmFolder "$(Build.SourcesDirectory)/Naati/Deployment Scripts/Helm"'
        workingDirectory: '$(buildSourcesDirectory)'
    
    # Publish Helm artifacts
    - task: PublishBuildArtifacts@1
      displayName: 'Publish Helm Artifacts'
      inputs:
        pathToPublish: '$(buildPackagesDirectory)'
        artifactName: 'helm-packages'

# Stage 4: Deploy to Multiple Environments
- ${{ each env in parameters.deployToEnvironments }}:
  - stage: Deploy_${{ env.environment }}
    displayName: 'Deploy to ${{ env.environment }}'
    dependsOn: HelmPackaging
    jobs:
    - deployment: DeployTo${{ env.environment }}
      displayName: 'Deploy to ${{ env.environment }}'
      environment: ${{ env.environment }}
      strategy:
        runOnce:
          deploy:
            steps:
            # Deploy using Helm
            - task: PowerShell@2
              displayName: 'Deploy to ${{ env.environment }} using Helm'
              inputs:
                targetType: 'inline'
                script: |
                  Write-Host "Deploying to ${{ env.environment }}..."
                  $helmFolder = "$(Build.SourcesDirectory)/Naati/Deployment Scripts/Helm"
                  Set-Location $helmFolder
                  
                  $envLower = "${{ env.environment }}".ToLower()
                  helm upgrade $envLower naati -f "./naati/_values.$envLower.yaml" --namespace $envLower --install --kube-context ${{ env.aksContext }}
                  
                  Write-Host "Deployment to ${{ env.environment }} completed successfully"
            
            # Verify deployment
            - task: PowerShell@2
              displayName: 'Verify ${{ env.environment }} Deployment'
              inputs:
                targetType: 'inline'
                script: |
                  Write-Host "Verifying deployment to ${{ env.environment }}..."
                  $envLower = "${{ env.environment }}".ToLower()
                  
                  # Check pod status
                  kubectl get pods -n $envLower --context ${{ env.aksContext }}
                  
                  # Check service status
                  kubectl get services -n $envLower --context ${{ env.aksContext }}
                  
                  Write-Host "Deployment verification completed"

# Stage 5: Cleanup (runs after all deployments)
- stage: Cleanup
  displayName: 'Cleanup and Logging'
  dependsOn: 
  - ${{ each env in parameters.deployToEnvironments }}:
    - Deploy_${{ env.environment }}
  condition: always()
  jobs:
  - job: CleanupAndLog
    displayName: 'Cleanup Images and Log Build'
    
    steps:
    # Log build information
    - task: PowerShell@2
      displayName: 'Log Build Information'
      inputs:
        targetType: 'inline'
        script: |
          $buildDate = Get-Date
          $deployedEnvs = "${{ join(',', parameters.deployToEnvironments.*.environment) }}"
          $logEntry = "$buildDate -> $(ContainerTag),$(HelmPackage),$(ncmsImageName),$(myNaatiImageName) - Deployed to: $deployedEnvs"
          Write-Host "Build completed: $logEntry"
          
          # Create build release notes
          $buildReleaseFile = "$(buildPackagesDirectory)/buildReleaseNotes.txt"
          $logEntry | Out-File -FilePath $buildReleaseFile -Append
    
    # Delete local images
    - task: PowerShell@2
      displayName: 'Delete Local Images'
      inputs:
        targetType: 'inline'
        script: |
          $deleteScript = "$(Build.SourcesDirectory)/Naati/Deployment Scripts/DeleteLocalImages.ps1"
          
          try {
            & $deleteScript -name $(ncmsImageName) -retentionDays 0
          } catch {
            Write-Warning "Failed to delete local NCMS images: $($_.Exception.Message)"
          }
          
          try {
            & $deleteScript -name $(myNaatiImageName) -retentionDays 0
          } catch {
            Write-Warning "Failed to delete local MyNaati images: $($_.Exception.Message)"
          }
      continueOnError: true
    
    # Delete old remote images
    - task: PowerShell@2
      displayName: 'Delete Old Remote Images'
      inputs:
        targetType: 'inline'
        script: |
          $deleteScript = "$(Build.SourcesDirectory)/Naati/Deployment Scripts/DeleteRemoteImages.ps1"
          
          $repositories = @($(ncmsImageName), $(myNaatiImageName), $(naatiBaseImageName))
          
          foreach ($repo in $repositories) {
            try {
              & $deleteScript -repository $repo -name $(repositoryName) -retentionDays 20
              Write-Host "Cleaned up old images for $repo"
            } catch {
              Write-Warning "Failed to delete old $repo images: $($_.Exception.Message)"
            }
          }
      continueOnError: true
    
    # Publish final build logs
    - task: PublishBuildArtifacts@1
      displayName: 'Publish Build Logs'
      inputs:
        pathToPublish: '$(buildPackagesDirectory)/buildReleaseNotes.txt'
        artifactName: 'build-logs'
